<?php
// $Id$

/**
 * @file alma.module
 * Drupal module implementing Axiell ABs Alma API.
 */

/**
 * Implementation of hook_flush_caches().
 */
function alma_flush_caches() {
  return array('cache_alma_requests');
}

/**
 * Implementation of hook_requirements().
 */
function alma_requirements($phase) {
  $requirements = array();
  // Ensure translations don't break at install time.
  $t = get_t();

  if (!function_exists('simplexml_load_string')) {
    $requirements['simplexml'] = array(
      'title' => 'SimpleXML',
      'description' => $t('The Alma module requires SimpleXML to function. Please install and/or enable SimpleXML in your PHP configuration.'),
      'severity' => REQUIREMENT_ERROR,
    );
  }

  return $requirements;
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function alma_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ding_provider') {
    return "plugins/$plugin";
  }
}

/**
 * Return a fully instantiated AlmaClient instance.
 */
function alma_client() {
  // This is basically a singleton. We also wait until right before
  // instantiating to include our required classes. That seems like a
  // decent performance tradeoff instead of loading everything on every
  // page load.
  static $client;
  if (!isset($client)) {
    $path = drupal_get_path('module', 'alma');
    // How the hell it can be possible that we include this twice, I
    // don't know, but I've seen it happen on the user page.
    require_once($path . '/lib/AlmaClient/AlmaClient.class.php');
    $client = new AlmaClient(variable_get('alma_base_url', ''));
  }
  return $client;
}

/**
 * Calls the Alma backend, possibly caching the result.
 *
 * @param $method
 *   The desired method.
 * @param ...
 *   Arguments to the method.
 *
 * @return mixed
 *   NULL on error, or the result of the method call.
 */
function alma_client_invoke($method) {
  static $cached_methods = array(
    'get_reservation_branches' => 28800,
  );
  $args = func_get_args();
  array_shift($args); // Lose the method.
  if (isset($cached_methods[$method])) {
    // Return data from cache if available.
    $cid = 'alma:' . $method . ":" . md5(serialize($args));
    $cache = cache_get($cid, 'cache_alma_requests');
    if ($cache && !empty($cache->data)) {
      return $cache->data;
    }
  }
  $client = alma_client();

  try {
    $result = call_user_func_array(array($client, $method), $args);
  }
  catch (Exception $e) {
    watchdog('alma', '@method error: “@message”', array('@method' => $method, '@message' => $e->getMessage(), WATCHDOG_ERROR));
    return NULL;
  }

  if (isset($cid) && $result) {
    cache_set($cid, $result, 'cache_alma_requests', $_SERVER['REQUEST_TIME'] + $cached_methods[$method]);
  }

  return $result;
}

/**
 * Clear the cache of a Alma method call.
 */
function alma_client_clear_cache($method) {
  $cid = 'alma:' . $method . ":" . md5(serialize($args));
  $cache = cache_clear_all($cid, 'cache_alma_requests');

}

/**
 * Get the complete organisation info from Alma.
 *
 * Includes branches, departments, locations, sublocations and
 * collections.
 *
 * @param boolean $reset
 *    Optional. If TRUE reset the cached data and reload.
 * @return array
 *    Array of the different organisational unit, each an array of their
 *    member units.
 */
function alma_get_organisation($reset=FALSE) {
  // Return data from cache if available.
  $cache = ($reset) ? FALSE : cache_get('alma_get_organisation', 'cache_alma_requests');
  if ($cache && !empty($cache->data)) {
    $organisation = $cache->data;
  }
  else {
    $organisation = array(
      'branch' => alma_client_invoke('get_branches'),
      'department' => alma_client_invoke('get_departments'),
      'location' => alma_client_invoke('get_locations'),
      'sublocation' => alma_client_invoke('get_sublocations'),
      'collection' => alma_client_invoke('get_collections'),
    );

    // Cache output for 24 hours if we got all the data correctly.
    if ($organisation['branch'] && $organisation['department'] && $organisation['location'] && $organisation['sublocation'] && $organisation['collection']) {
      cache_set('alma_get_organisation', $organisation, 'cache_alma_requests', $_SERVER['REQUEST_TIME'] + 86400);
    }
  }

  return $organisation;
}

/**
 * Get a patron's reservations
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's four digit PIN code.
 * @return array
 *    The reservations as an array.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_get_reservations($borr_card, $pin_code) {
  try {
    return alma_client()->get_reservations($borr_card, $pin_code);
  } catch (Exception $e) {
    watchdog('alma_user', 'get_reservations error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Get a patron's debts
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's four digit PIN code.
 * @return array
 *    The loans as an array.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_get_debts($borr_card, $pin_code) {
  try {
    return alma_client()->get_debts($borr_card, $pin_code);
  } catch (Exception $e) {
    watchdog('alma_user', 'get_debts error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Add reservation.
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's current four digit PIN code.
 * @param array $reservation
 *    Data for the reservation we're adding.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_add_reservation($borr_card, $pin_code, $reservation) {
  // If reservation does not have a valid_to date, use the default
  // interest period from alma_user, if available.
  if (!isset($reservation['valid_to']) && function_exists('alma_user_user')) {
    $account = user_load($GLOBALS['user']->uid);
    $period = (isset($account->interest_period) && $account->interest_period > 10) ? $account->interest_period : ALMA_USER_DEFAULT_INTEREST_PERIOD;

    if ($period > 0) {
      $reservation['valid_to'] = date('Y-m-d', $_SERVER['REQUEST_TIME'] + $period * 86400);
    }
  }
  try {
    return alma_client()->add_reservation($borr_card, $pin_code, $reservation);
  }
  catch (Exception $e) {
    watchdog('alma_user', 'add_reservation error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Remove a reservation
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's four digit PIN code.
 * @param array $reservation
 *    Data for the reservation we're removing.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_remove_reservation($borr_card, $pin_code, $reservation) {
  try {
    return alma_client()->remove_reservation($borr_card, $pin_code, $reservation);
  }
  catch (Exception $e) {
    watchdog('alma_user', 'remove_reservation error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Check if user has reservation already.
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's current four digit PIN code.
 * @param string $item_id
 *    Local ID for the item we're checking for.
 * @return boolean
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_user_has_reservation($borr_card, $pin_code, $item_id) {
  try {
    $reservations = alma_client()->get_reservations($borr_card, $pin_code);
    foreach ($reservations as $res) {
      if ($res['record_id'] == $item_id) {
        return TRUE;
      }
    }
  }
  catch (Exception $e) {
    watchdog('alma_user', 'get_reservations error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
  }

  return FALSE;
}

/**
 * Pay one or more Alma debts.
 *
 * @param string $debt_ids
 *    IDs for the debts, comma-separated.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_add_payment($debt_ids, $order_id = NULL) {
  try {
    $data = alma_client()->add_payment($debt_ids, $order_id);
  } catch (Exception $e) {
    watchdog('alma_user', 'add_payment error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
  }
}

/**
 * Change user’s preferred branch.
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's current four digit PIN code.
 * @param string $branch_code
 *    New preferred branch.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_change_patron_preferences($borr_card, $pin_code, $branch_code) {
  try {
    $data = alma_client()->change_patron_preferences($borr_card, $pin_code, $branch_code);
  } catch (Exception $e) {
    watchdog('alma_user', 'change_patron_preferences error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
  }
}

/**
 * Add an Alma absent period.
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's current four digit PIN code.
 * @param string $from_date
 *    Absent period start date.
 * @param string $to_date
 *    Absent period start date.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_add_absent_period($borr_card, $pin_code, $from_date, $to_date) {
  try {
    $data = alma_client()->add_absent_period($borr_card, $pin_code, $from_date, $to_date);
  } catch (Exception $e) {
    watchdog('alma_user', 'add_absent_period error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
  }
}

/**
 * Change existing absent period.
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's current four digit PIN code.
 * @param string $absent_id
 *    ID for existing period.
 * @param string $from_date
 *    Absent period start date.
 * @param string $to_date
 *    Absent period start date.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_change_absent_period($borr_card, $pin_code, $absent_id, $from_date, $to_date) {
  try {
    $data = alma_client()->change_absent_period($borr_card, $pin_code, $absent_id, $from_date, $to_date);
  } catch (Exception $e) {
    watchdog('alma_user', 'change_absent_period error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
  }
}

/**
 * Remove existing absent period.
 *
 * @param string $borr_card
 *    Library patron's borrowing card number. Either just an arbitrary
 *    number printed on their library card or their CPR-code.
 * @param string $pin_code
 *    Library patron's current four digit PIN code.
 * @param string $absent_id
 *    ID for existing period.
 *
 * @todo
 *  Refactor callers to use alma_client_invoke and remove this.
 */
function alma_client_remove_absent_period($borr_card, $pin_code, $absent_id) {
  try {
    $data = alma_client()->remove_absent_period($borr_card, $pin_code, $absent_id);
  } catch (Exception $e) {
    watchdog('alma_user', 'remove_absent_period error: “@message”', array('@message' => $e->getMessage()), WATCHDOG_ERROR);
  }
}

/**
 * Calculate the time to wait for a reservation.
 *
 * @param array $records
 *    The records array from a alma_client_catalogue_record_detail request.
 * @return array
 *    Wait time, keyed by Alma ID.
 */
function alma_calculate_wait_time($records) {
  $wait = array();

  foreach ($records as $record) {
    if ($record['available_count'] > 0) {
      $wait[$record['alma_id']] = t('A couple of days');
    }
    else {
      $total = 0;

      foreach ($record['holdings'] as $holding) {
        $total += $holding['total_count'];
      }

      if ($total > 0 && $record['reservation_count'] > 0) {
        $days = $total / $record['reservation_count'] * 30;

        if ($days < 9) {
          $wait[$record['alma_id']] = t('About a week');
        }
        elseif ($days < 16) {
          $wait[$record['alma_id']] = t('About two weeks');
        }
        elseif ($days < 35) {
          $wait[$record['alma_id']] = t('About a month');
        }
        elseif ($days < 65) {
          $wait[$record['alma_id']] = t('About two months');
        }
        else {
          $wait[$record['alma_id']] = t('More than two months');
        }
      }
      else {
        $wait[$record['alma_id']] = t('Unknown');
      }
    }
  }

  return $wait;
}
